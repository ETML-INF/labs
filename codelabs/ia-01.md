author: Helder Costa
summary: ia tuto
id: ia-01
categories: ia,python,dev
tags: ict
environments: Web
status: Published
feedback link: https://git.section-inf.ch/jmy/labs/issues
analytics account: UA-170792591-1

# Introduction aux Principes de l‚ÄôIA

## Vue d‚Äôensemble
Duration: 0:01:00

![Alt text](assets/ia/ia-1.png)

Survey
: Quelle est votre premi√®re r√©action en entendant parler d'intelligence artificielle (IA) ?
<ul>
   <li><strong>C'est fascinant, mais un peu effrayant.</strong> - Int√©r√™t m√™l√© d'appr√©hension face aux possibilit√©s et aux implications de l'IA.</li>   
   <li><strong>√áa va changer le monde !</strong> - Enthousiasme pour l'impact potentiel de l'IA sur diff√©rents aspects de la vie.</li>
   <li><strong>On est encore loin des robots intelligents...</strong> - Scepticisme quant au niveau actuel de d√©veloppement et aux attentes souvent exag√©r√©es.</li>
</ul>

## Bonjour jeune nageur !
Duration: 0:05:00

Bienvenue dans cette aventure passionnante o√π tu vas cr√©er ta premi√®re IA ! L‚Äôobjectif n‚Äôest pas de rivaliser avec ChatGPT ou Elon Musk, mais de d√©couvrir le monde fascinant de l‚Äôintelligence artificielle.

Nous aurons deux projets distincts. Nous commencerons par cr√©er un syst√®me de chat, puis nous cr√©erons un syst√®me d‚Äôanalyse d‚Äôimage capable de pr√©dire l‚Äôobjet principal de l‚Äôimage.

### Cr√©e ton propre PyChat

Il s'agit d'un petit programme qui vous demande de lui poser une question. Ensuite, il va chercher dans sa base de donn√©es selon un syst√®me moyennement complexe qui d√©coupe la phrase en mots cl√©s. En utilisant ces mots cl√©s, il tente de trouver la r√©ponse la plus pertinente possible.

**Comment fonctionne la pr√©diction dans PyChat ?**

1. **Analyse de la question** : Lorsque vous posez une question, le programme commence par analyser la phrase. Il identifie les mots cl√©s importants en supprimant les mots courants comme "le", "la", "et", etc.

2. **Recherche dans la base de donn√©es** : Une fois les mots cl√©s identifi√©s, le programme les utilise pour rechercher des r√©ponses potentielles dans sa base de donn√©es. Il compare les mots cl√©s de la question avec ceux des r√©ponses stock√©es.

3. **Utilisation des statistiques** : Le programme utilise des mod√®les statistiques pour pr√©dire les mots qui suivent les mots cl√©s identifi√©s. Par exemple, si la question contient le mot "m√©t√©o", le programme sait que des mots comme "aujourd'hui", "demain", "pr√©visions" sont statistiquement susceptibles de suivre. C'est un peu comme lorsque nous utilisons le dictionnaire de nos smartphones pour √©crire un message ; le programme sugg√®re les mots suivants en fonction de ce que nous avons d√©j√† √©crit.

4. **S√©lection de la r√©ponse** : En combinant les mots cl√©s et les pr√©dictions statistiques, le programme √©value les r√©ponses possibles. Il s√©lectionne la r√©ponse qui correspond le mieux aux mots cl√©s et aux pr√©dictions.

5. **Affichage de la r√©ponse** : Enfin, le programme affiche la r√©ponse qu'il a jug√©e la plus pertinente.

Negative
: Avertissement : Il s‚Äôagit d‚Äôune simplification du syst√®me. 
Les v√©ritables syst√®mes de chat bas√©s sur l‚Äôintelligence artificielle utilisent des algorithmes beaucoup plus complexes et sophistiqu√©s pour comprendre et r√©pondre aux questions.

### Mise en place d'un protocole de test

Pour comprendre le fonctionnement du chat, tu trouveras plus loin dans ce tutoriel un sc√©nario dont le but est de poser des questions et de nous faire un retour sur des r√©flexions telles que : la r√©ponse est-elle pertinente ? Le syst√®me apprend-il ? Enfin, comment le syst√®me pourrait-il s'am√©liorer ?

N'oublie pas que l'id√©al est que tu te forges ta propre vision et compr√©hension.

Pr√™t √† commencer ? Allons-y ! üí™


## Pr√©requis üõ†Ô∏è
Duration: 0:02:00

Id√©alement les [tutoriels python](https://labs.section-inf.ch/?cat=python) ont √©t√© r√©alis√©s.

De plus, la programmation √©tant un long voyage, semblable √† l'apprentissage d'une langue üåç, il faut d'abord ma√Ætriser les bases, comme les mots, la grammaire, et les diff√©rents sons üó£Ô∏è. 
Avec le temps, nous formerons des phrases, et avec encore plus de pratique, nous comprendrons leur sens üß†. 
Puis, en saisissant les nuances üßê, nous pourrons appr√©cier les blagues culturelles üé≠.

> Un jour, un homme africain part √† la chasse. Apr√®s une longue journ√©e dans la savane, il rentre √† la maison les mains vides. Sa femme lui demande :  
> ¬´ Ch√©ri, o√π est le gibier ? ¬ª  
> L'homme r√©pond : ¬´ Aujourd'hui j'ai attrap√© quelque chose de plus pr√©cieux qu'un simple animal... j'ai attrap√© de l'exp√©rience ! ¬ª

- **Humour culturel** : Cette blague montre comment l'humour peut varier selon les contextes culturels.
- **Le√ßons de vie** : Les exp√©riences peuvent √™tre aussi pr√©cieuses que les biens mat√©riels. M√™me sans gibier, l'homme a acquis une le√ßon importante.
- **Contextualisation** : Dans l'apprentissage, il est crucial de reconna√Ætre la valeur des exp√©riences, m√™me si les r√©sultats ne sont pas imm√©diatement visibles.

Ici, nous sommes au d√©but, donc pas le temps de tout faire nous-m√™mes. Je te propose donc une petite exploration des biblioth√®ques que nous utiliserons dans ce tutoriel pour comprendre les composants essentiels de notre syst√®me üß©.

## Explication des Biblioth√®ques (voir code ci apr√®s)
Duration: 0:01:00

1. **`import nltk`** : Pour le traitement du langage naturel, notamment le tokenizer `punkt` pour diviser le texte en mots et phrases.
2. **`from sklearn.feature_extraction.text import CountVectorizer`** : Convertit le texte en une matrice de comptage des mots pour l'entra√Ænement des mod√®les.
3. **`from sklearn.naive_bayes import MultinomialNB`** : Algorithme de classification bas√© sur le th√©or√®me de Bayes, adapt√© aux donn√©es textuelles.
4. **`import json`** : Manipule les fichiers JSON pour charger et sauvegarder les donn√©es d'entra√Ænement.
5. **`import joblib`** : S√©rialise les objets Python pour sauvegarder et charger les mod√®les d'apprentissage automatique.
6. **`import string`** : Fournit des outils pour manipuler les cha√Ænes de caract√®res, comme supprimer la ponctuation.

## Installation des d√©pendances üõ†Ô∏è
Duration: 0:03:00

0. Copie-colle le contenu suivant dans un fichier nomm√© *requirements.txt*
```text
certifi==2024.7.4
charset-normalizer==3.3.2
click==8.1.7
colorama==0.4.6
filelock==3.15.4
fsspec==2024.6.1
huggingface-hub==0.24.5
idna==3.7
Jinja2==3.1.4
joblib==1.4.2
MarkupSafe==2.1.5
mpmath==1.3.0
networkx==3.3
nltk==3.8.2
numpy==2.0.1
packaging==24.1
PyYAML==6.0.2
regex==2024.7.24
requests==2.32.3
safetensors==0.4.4
scikit-learn==1.5.1
scipy==1.14.0
setuptools==72.2.0
sympy==1.13.2
threadpoolctl==3.5.0
tokenizers==0.19.1
torch==2.4.0
tqdm==4.66.5
transformers==4.44.0
typing_extensions==4.12.2
urllib3==2.2.2
wheel==0.44.0
```

1. **Ouvre ton terminal**.

2. **Installe les biblioth√®ques n√©cessaires** :
   Tu devras avoir un fichier nomm√© `requirements.txt` contenant toutes les d√©pendances n√©cessaires pour ton projet. Pour installer ces d√©pendances, ex√©cute la commande suivante :

   ```shell
   python -m pip install -r requirements.txt
   ```

## Instructions de code üìù
Duration: 0:05:00

Ensuite, copie-colle le code suivant dans un fichier Python :

```python
import nltk
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.naive_bayes import MultinomialNB
import json
import joblib
import string
import sys
import io

# Assurer que la sortie standard utilise l'encodage UTF-8
sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')

# T√©l√©charger les ressources n√©cessaires de NLTK
nltk.download('punkt')

# Fonction de pr√©traitement du texte
def preprocess_text(text):
    text = text.lower()  # Conversion en minuscules
    text = text.translate(str.maketrans('', '', string.punctuation))  # Suppression de la ponctuation
    return text

# Charger les donn√©es d'apprentissage depuis un fichier
def load_data(file_path):
    with open(file_path, 'r', encoding='utf-8') as file:
        data = json.load(file)
    return data["questions"], data["responses"]

# Sauvegarder les donn√©es d'apprentissage dans un fichier
def save_data(file_path, questions, responses):
    data = {"questions": questions, "responses": responses}
    with open(file_path, 'w', encoding='utf-8') as file:
        json.dump(data, file, ensure_ascii=False, indent=4)

def save_model(file_path, model, vectorizer):
    joblib.dump((model, vectorizer), file_path)

def load_model(file_path):
    return joblib.load(file_path)

# Fonction pour entra√Æner le mod√®le de r√©ponse
def train_response_model(questions, responses):
    vectorizer = CountVectorizer()
    X = vectorizer.fit_transform([preprocess_text(question) for question in questions])
    model = MultinomialNB()
    model.fit(X, responses)
    return model, vectorizer

# Initialisation
data_file_path = "data.json"
model_path = "response_model.pkl"

# Charger les donn√©es
questions, responses = load_data(data_file_path)

# Entra√Æner ou charger le mod√®le
try:
    model, vectorizer = load_model(model_path)
except FileNotFoundError:
    model, vectorizer = train_response_model(questions, responses)
    save_model(model_path, model, vectorizer)

def predict_response(question):
    question = preprocess_text(question)
    X = vectorizer.transform([question])
    prediction = model.predict(X)[0]
    return prediction

def main():
    while True:
        try:
            question = input("Posez-moi une question: ")
            
            # Trouver la r√©ponse correspondant √† la question
            response = predict_response(question)
            print(f"R√©ponse: {response}")
            
            feedback = input("Est-ce que la r√©ponse est correcte? (oui/non) ").strip().lower()
            if feedback == "non":
                correct_response = input("Quelle devrait √™tre la bonne r√©ponse? ").strip()
                questions.append(question)
                responses.append(correct_response)
                # R√©entra√Æner le mod√®le avec les nouvelles donn√©es
                global model, vectorizer
                model, vectorizer = train_response_model(questions, responses)
                save_data(data_file_path, questions, responses)
                save_model(model_path, model, vectorizer)
                print("Merci pour le retour, j'ai appris quelque chose de nouveau!")
            elif feedback == "oui":
                print("Merci pour votre confirmation!")
            else:
                print("R√©ponse non reconnue. Veuillez r√©pondre par 'oui' ou 'non'.")
        except KeyboardInterrupt:
            print("\nProgramme termin√©.")
            break
        except Exception as e:
            print(f"Une erreur est survenue: {e}")

if __name__ == "__main__":
    main()
```

## T√©l√©charger les fichiers ressources
Duration: 0:02:00

Compl√®te le projet en ajoutant les fichiers manquant pr√©sents dans [l‚Äôarchive suivante](https://eduvaud.sharepoint.com/:u:/s/msteams_d0db31/EW8v5Lrtm89DnMLaEqhbbioB5iKOS1AknUA4xSNVIFp-tA?e=jIHL4Z)

## üé¨ Lancer le programme
Duration: 0:02:00

Ex√©cute la commande suivante :  
```bash
python pysChat.py
```
Suis les instructions √† l'√©cran pour interagir avec le syst√®me de chat. 

![Programme lanc√©](assets/ia/startPysChat.jpg "Programme lanc√©")

## Activit√© üõ†Ô∏è
Duration: 0:15:00

Super, nous avons termin√© le programme ! üéâ Il est maintenant temps de le tester et d'en tirer des conclusions. üß©

Pour cela, comme indiqu√© plus haut, nous allons mettre en place un sc√©nario de test. Comme cela peut √™tre nouveau pour vous, je vais vous guider tout au long du processus. üë®‚Äçüè´

Le protocole consiste simplement √† poser des questions au programme et √† indiquer si les r√©ponses sont pertinentes ou non. ü§î‚úÖ‚ùå

### Sc√©nario de test

Ci-dessous se trouve une s√©rie de questions simples, sans lien entre elles. votre t√¢che est de d√©terminer si chaque r√©ponse propos√©e est correcte ou non.

- **Question :** "Quelle est la capitale de la France ?"  
   **R√©ponse attendue :** "Paris"

- **Question :** "Quel est le r√©sultat de 2 + 2 ?"  
   **R√©ponse attendue :** "4"

- **Question :** "Comment s'appelle le pr√©sident des √âtats-Unis en 2024 ?"  
   **R√©ponse attendue :** "Joe Biden" (si applicable)

**√Ä votre avis, pourquoi cette r√©ponse pourrait-elle √™tre incorrecte ?**

---

### Histoire √† raconter

- **Question :** Connais-tu Sarah ?  
   **R√©ponse :** La r√©ponse est probablement incorrecte. Dites que c'est une coll√®gue.

- **Question :** Sais-tu qui est notre chef de projet ?  
   **R√©ponse :** La r√©ponse est insatisfaisante. Dites que c'est Sarah.

- **Question :** As-tu d√©j√† travaill√© avec Sarah sur un projet sp√©cifique ?  
   **R√©ponse :** La r√©ponse est vague. Dites que vous avez collabor√© avec elle sur le projet de refonte du site web de l'entreprise, o√π elle a jou√© un r√¥le cl√© dans la coordination des √©quipes.

- **Question :** Es-tu au courant de la date de la prochaine r√©union d'√©quipe ?  
   **R√©ponse :** La r√©ponse manque de pr√©cision. Dites que Sarah a mentionn√© que la r√©union est pr√©vue pour mardi prochain √† 10 heures, dans la salle de conf√©rence principale.

- **Question :** Connais-tu les objectifs fix√©s par Sarah pour ce trimestre ?  
   **R√©ponse :** La r√©ponse est incompl√®te. Dites que Sarah a fix√© des objectifs pr√©cis, notamment l'am√©lioration de la collaboration entre les d√©partements et l'augmentation de l'efficacit√© des processus internes.

- **Question :** Qui a r√©cemment pris la responsabilit√© de superviser les nouvelles embauches dans l'√©quipe ?  
   **R√©ponse attendue :** Sarah, √©tant donn√© son r√¥le de chef de projet et son implication dans les processus internes.

- **Question :** Sais-tu qui a propos√© l'id√©e de lancer une enqu√™te de satisfaction des employ√©s ce trimestre ?  
   **R√©ponse attendue :** Sarah, en raison de son initiative et de son souci d'am√©liorer les processus internes.

---

### Test logique

- **Question :** "Si un avion vole √† 800 km/h pendant 2 heures, quelle distance parcourt-il ?"  
   **R√©ponse attendue :** "1600 km"  
   **V√©rification :** Est-ce que la r√©ponse est correcte ?  
   **Objectif :** Tester la capacit√© du mod√®le √† comprendre et traiter des questions n√©cessitant une logique de base.

- **Question :** "Si je te dis que 2 + 2 = 5, que dis-tu ?"  
   **R√©ponse attendue :** "C'est incorrect."  
   **V√©rification :** Est-ce que la r√©ponse est correcte ?  
   **Objectif :** Tester la capacit√© du mod√®le √† d√©tecter des erreurs logiques.

- **Question :** "Peux-tu me raconter une blague ?"  
   **R√©ponse attendue :** Une blague ou une indication que le mod√®le ne peut pas r√©pondre √† cette question.  
   **V√©rification :** Est-ce que la r√©ponse est correcte ?  
   **Objectif :** Tester la flexibilit√© du mod√®le pour des questions ouvertes.

---

### Analyse des r√©ponses et r√©ajustement

apr√®s avoir ex√©cut√© ces sc√©narios de test, vous devez :

1. **analyser les r√©ponses :** v√©rifiez si les r√©ponses sont correctes par rapport aux attentes.
2. **fournir du feedback :** si une r√©ponse est incorrecte, fournissez la bonne r√©ponse et voyez si le mod√®le s'am√©liore apr√®s r√©entra√Ænement.
3. **r√©p√©ter le processus :** continuez √† poser des questions jusqu'√† ce que le mod√®le soit suffisamment robuste pour r√©pondre √† la plupart des questions de mani√®re satisfaisante.

**l'objectif est d'observer l'am√©lioration progressive du syst√®me, qui ne fonctionne pas parfaitement au d√©part.**

## Explication du Code par Blocs
Duration: 0:05:00

### 1. Importations et Configuration

```python
import nltk
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.naive_bayes import MultinomialNB
import json
import joblib
import string
import sys
import io

# Assurer que la sortie standard utilise l'encodage UTF-8
sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
```

- **`import nltk`** : Charge la biblioth√®que Natural Language Toolkit pour le traitement du langage naturel.
- **`from sklearn.feature_extraction.text import CountVectorizer`** : Importation de `CountVectorizer` pour convertir les textes en matrices de fr√©quence de mots.
- **`from sklearn.naive_bayes import MultinomialNB`** : Importation de l'algorithme de classification Na√Øve Bayes pour l'apprentissage automatique.
- **`import json`** : Permet la manipulation des fichiers JSON pour charger et sauvegarder les donn√©es.
- **`import joblib`** : Utilis√© pour la s√©rialisation des objets Python, comme les mod√®les d'apprentissage automatique.
- **`import string`** : Fournit des outils pour la manipulation de cha√Ænes de caract√®res, comme la suppression de la ponctuation.
- **`import sys`** et **`import io`** : Pour configurer l'encodage UTF-8 de la sortie standard.

### 2. Pr√©traitement du Texte

```python
# T√©l√©charger les ressources n√©cessaires de NLTK
nltk.download('punkt')

# Fonction de pr√©traitement du texte
def preprocess_text(text):
    text = text.lower()  # Conversion en minuscules
    text = text.translate(str.maketrans('', '', string.punctuation))  # Suppression de la ponctuation
    return text
```

- **`nltk.download('punkt')`** : T√©l√©charge le tokenizer `punkt` de NLTK pour diviser le texte en mots et phrases.
- **`preprocess_text`** : Fonction pour normaliser le texte en le convertissant en minuscules et en supprimant la ponctuation.

### 3. Gestion des Donn√©es

```python
# Charger les donn√©es d'apprentissage depuis un fichier
def load_data(file_path):
    with open(file_path, 'r', encoding='utf-8') as file:
        data = json.load(file)
    return data["questions"], data["responses"]

# Sauvegarder les donn√©es d'apprentissage dans un fichier
def save_data(file_path, questions, responses):
    data = {"questions": questions, "responses": responses}
    with open(file_path, 'w', encoding='utf-8') as file:
        json.dump(data, file, ensure_ascii=False, indent=4)
```

- **`load_data`** : Charge les questions et r√©ponses depuis un fichier JSON.
- **`save_data`** : Sauvegarde les questions et r√©ponses dans un fichier JSON.

### 4. Gestion du Mod√®le

```python
def save_model(file_path, model, vectorizer):
    joblib.dump((model, vectorizer), file_path)

def load_model(file_path):
    return joblib.load(file_path)
```

- **`save_model`** : Sauvegarde le mod√®le et le vecteur de caract√©ristiques dans un fichier avec `joblib`.
- **`load_model`** : Charge le mod√®le et le vecteur de caract√©ristiques depuis un fichier.

### 5. Entra√Ænement du Mod√®le

```python
# Fonction pour entra√Æner le mod√®le de r√©ponse
def train_response_model(questions, responses):
    vectorizer = CountVectorizer()
    X = vectorizer.fit_transform([preprocess_text(question) for question in questions])
    model = MultinomialNB()
    model.fit(X, responses)
    return model, vectorizer
```

- **`train_response_model`** : Entra√Æne un mod√®le de classification Na√Øve Bayes pour pr√©dire les r√©ponses bas√©es sur les questions. Utilise `CountVectorizer` pour transformer le texte en une matrice de fr√©quences de mots, puis entra√Æne le mod√®le avec ces donn√©es.

### 6. Initialisation et Ex√©cution Principale

```python
# Initialisation
data_file_path = "data.json"
model_path = "response_model.pkl"

# Charger les donn√©es
questions, responses = load_data(data_file_path)

# Entra√Æner ou charger le mod√®le
try:
    model, vectorizer = load_model(model_path)
except FileNotFoundError:
    model, vectorizer = train_response_model(questions, responses)
    save_model(model_path, model, vectorizer)
```

- **Initialisation** : D√©finit les chemins pour les fichiers de donn√©es et le mod√®le.
- **Chargement des donn√©es** : Charge les questions et r√©ponses depuis le fichier JSON.
- **Entra√Ænement ou chargement du mod√®le** : Essaie de charger le mod√®le pr√©existant, ou l'entra√Æne si le fichier du mod√®le n'existe pas.

### 7. Pr√©diction et Interaction

```python
def predict_response(question):
    question = preprocess_text(question)
    X = vectorizer.transform([question])
    prediction = model.predict(X)[0]
    return prediction

def main():
    while True:
        try:
            question = input("Posez-moi une question: ")
            
            # Trouver la r√©ponse correspondant √† la question
            response = predict_response(question)
            print(f"R√©ponse: {response}")
            
            feedback = input("Est-ce que la r√©ponse est correcte? (oui/non) ").strip().lower()
            if feedback == "non":
                correct_response = input("Quelle devrait √™tre la bonne r√©ponse? ").strip()
                questions.append(question)
                responses.append(correct_response)
                # R√©entra√Æner le mod√®le avec les nouvelles donn√©es
                global model, vectorizer
                model, vectorizer = train_response_model(questions, responses)
                save_data(data_file_path, questions, responses)
                save_model(model_path, model, vectorizer)
                print("Merci pour le retour, j'ai appris quelque chose de nouveau!")
            elif feedback == "oui":
                print("Merci pour votre confirmation!")
            else:
                print("R√©ponse non reconnue. Veuillez r√©pondre par 'oui' ou 'non'.")
        except KeyboardInterrupt:
            print("\nProgramme termin√©.")
            break
        except Exception as e:
            print(f"Une erreur est survenue: {e}")

if __name__ == "__main__":
    main()
```

- **`predict_response`** : Pr√©pare la question, transforme le texte en une matrice de caract√©ristiques, et pr√©dit la r√©ponse en utilisant le mod√®le.
- **`main`** : Fonction principale qui boucle pour prendre des questions de l'utilisateur, fournir des r√©ponses, et g√©rer les retours de feedback pour am√©liorer le mod√®le.


## Synth√®se

![https://docs.google.com/forms/d/e/1FAIpQLSdgvNnN_qdtcta6VOWNShCJgL3bHiL0kITMamG84VLQigh8_A/viewform?embedded=true](codelabs/assets/linux.svg)